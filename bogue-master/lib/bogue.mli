(* !!!!!!!!! autogenerated, don't edit !!!!!!!!! *)



(** General purpose GUI (Graphical user interface) library for Ocaml.

   Bogue is a lightweight and fast GUI for developing desktop applications,
   games, or for easy debugging of non-GUI programs.

   Bogue is entirely written in {{:https://ocaml.org/}ocaml} except for the
   hardware accelerated graphics library {{:https://www.libsdl.org/}SDL2}.

@version 20200630

@author Vu Ngoc San

*)

(** {3 Quick start}

 For a quick start, see Bogue's {{:Principles.html}general principles}, and the
   minimal {{!example}example}.


*)

(* ---------------------------------------------------------------------------- *)

(** {1 List of Modules}

The only thing that [open Bogue] does is to bring these modules into your
   namespace. The have quite common names, so beware of conflict. In case of
   doubt, don't open [Bogue], and access to the modules by using the [Bogue]
   prefix, for instance [Bogue.Widget.label]. The {!Widget} and {!Layout}
   modules are probably the ones that you will find yourself using the most, so
   it's a good idea to alias them:

{[module W = Bogue.Widget 
module L = Bogue.Layout]} 
*)



(** Theming variables

A number of variables can be modified from a configuration file. They are called
   Theme variables. 

- Each theme has its own directory under
   [$HOME/.config/bogue/themes], in which there is a [bogue.conf] file where the
   Theme variables are defined.
- The user config file [$HOME/.config/bogue.conf] overrides the theme files.
- The syntax of the config file is [VARIABLE = value], one entry per line. 
  Notice the spaces surroundind [=]. Comment lines starting by [#] are ignored. 
  For instance:
{[
# my bogue.conf
THEME = dark
BACKGROUND = color:azure
]}

Here is the list of Theme variables:

- [BACKGROUND]: the default background for all windows. It can be a color 
  (eg. [color:darkturquoise] or [color:#00CED1]), or an image file 
  (eg. [file:myimage.png]).
  In the latter case, the file is searched in the current theme's directory, 
  unless the file string starts with [/], in which case it should be an 
  absolute path (eg. [file:/home/alice/myimage.png]).
- [BG_COLOR]: A background color (eg. [darkturquoise], or [#00CED1]) 
  that is used by default by some widgets/layouts.
  It should be clearly visible over the [BACKGROUND].
- [BUTTON_COLOR_ON]: the color of active buttons.
- [BUTTON_COLOR_OFF]: the color of inactive buttons.
- [CHECK_ON]: the image used for the 'checked' icon. It can be a file 
  (eg. [myimage.png]) or a font-awesome icon (eg. [fa:check-square-o]).
- [CHECK_OFF]: the image used for the 'unchecked' icon. See [CHECK_ON].
- [CURSOR_COLOR]
- [DIR]:  The directory containing the themes subdirectories. Default: auto   detected at startup, usually [$HOME/.config/bogue/themes]
- [FA_DIR]: The fontawesome directory inside [DIR/common/].
- [FAINT_COLOR]: A non-obstrusive color for disabled options or 
  text of little importance.
- [LABEL_COLOR]: The color for text or icon labels.
- [LABEL_FONT]: path of a TTF font for text labels. Eg: [Ubuntu-R.ttf].
- [LABEL_FONT_SIZE]: integer, eg [14].
- [MENU_HL_COLOR]: the color for highlighting selected menu entries.
- [MENU_BG_COLOR]
- [MONO_FONT]: monospace font.
- [ROOM_MARGIN]
- [SCALE]: global scale (any non-negative float). For instance if [SCALE = 2.], 
  all dimensions given to Bogue functions will be multiplied by 2 before 
  rendering to obtain 
  the hardware size in pixels. 
  If set to [0.] or not specified, it is autodetected to match your screen DPI
  (using [xdpyinfo], if present). 
- [SEL_BG_COLOR]: background color for selected items in lists.
- [SEL_FG_COLOR]: text color for selected items in lists.
- [SMALL_FONT_SIZE]: integer. Used for instance for tooltips popups.
- [TEXT_COLOR]: color of standard text displays.
- [TEXT_FONT]
- [TEXT_FONT_SIZE]

All variables with "COLOR" in their name can be specified either with RGB hexadecimal like [#00CED1], or with a standard html name like [darkturquoise], see {{:https://www.rapidtables.com/web/color/html-color-codes.html}this color table}.

{5 {{:graph-b_theme.html}Dependency graph}} *)
module Theme : sig

  (** {2 Accessing Theme variables}

     Theme variables are essentially for Bogue's internal use, but sometimes it
     can be useful to access their values. See above for their description. *)
  
  val room_margin : int
    
  val scale_int : int -> int
(** Conversion: Bogue dimension -> hardware pixel dimension. The latter is
   obtained by multiplying by [SCALE]. *)
    
end (* of Theme *)

(* ---------------------------------------------------------------------------- *)

     
(** Utilities

    This module contains several utilities, in particular for debug logs.
    
{5 {{:graph-b_utils.html}Dependency graph}}
*)
module Utils : sig

  (** {2 Debugging} *)

  val printd : int -> ('a, unit, string, unit) format4 -> 'a
  (** For instance [printd debug_warning "The value x=%u is too big" x] will
     print a message in the console only if the {!debug} variable contains the
     [debug_warning] flag. *)

  val debug : bool ref
  val debug_code : int ref
  (** Logical {e ored} of [!debug] with debug flags (below) controls the amount
     of debuging. *)

  (** {3 Binary masks (=flags) for debugging messages.} *)

  val debug_thread : int
  val debug_warning : int
  val debug_graphics : int
  val debug_error : int
  val debug_io : int
  val debug_memory : int
  val debug_board : int
  val debug_event : int
  val debug_custom : int
    
  (** {2 Maths} *)

  val pi : float
    
  val round : float -> int
  (** Round float to nearest integer. *)

  val imax : int -> int -> int
  (** [imax a b] returns max([a], [b]). *)

  val imin : int -> int -> int
  (** [imin a b] returns min([a], [b]). *)
    
  (** {2 Tsdl Result} *)
    
  val go : ('a, 'b) result -> 'a
  (** Transform a [result] into a standard value, or fail with an error. Used
      only for SDL functions. *)

  (** {2 Options}

      Monadic style operations on optional variables. *)

  val map_option : 'a option -> ('a -> 'b) -> 'b option

  val do_option : 'a option -> ('a -> unit) -> unit

  val default : 'a option -> 'a -> 'a

  exception None_option
    
  val remove_option : 'a option -> 'a
  (** Warning: [remove_option None] will raise the {!None_option} exception. *)

  (** {2 Others} *)

  val run : (unit -> 'a) -> 'a
  (**  [run f] is equivalent to [f ()]. *)
    
end (* of Utils *)

(* ---------------------------------------------------------------------------- *)


(** Time in msec 

{5 {{:graph-b_time.html}Dependency graph}}
*)
module Time : sig
  type t = int

  val now : unit -> t
  (** Time elapsed from the initialization of SDL (roughly, since the start of
      your program). *)
    
  val adaptive_fps : int -> (unit -> unit) * (unit -> unit)
  (** Create helper functions to help controlling the frame rate of the graphics
     loop. This is only useful if you have your own graphics loop, and do not
     use {!Main.run}.

     [adaptive_fps 60] returns two functions [start,fps]. The statement [start
     ()] will start the timing. At each iteration of your loop, you should call
     [fps ()], which will try to sleep long enough to achieve the desired 60FPS
     rate. It works on average: if some frames take longer, it will shorten the
     next frame to keep up. However, it tries to be nice to the CPU: even if one
     is really too slow, it will guarantee a 5ms sleep to the CPU and {e not}
     try to keep up. *)
                                             
end (* of Time *)

(* ---------------------------------------------------------------------------- *)

(** Global variables with mutex

   In a GUI, it is quite likely that a thread has to modify a variable owned by
   another thread. This is particularly true in Bogue. In order to protect
   against concurrent access to a shared variable, one should use a special kind
   of variable. This is the goal of this module.

   {b Warning:} working with threads is subtle, and using {!Var} will not
   magically make all problems disappear. In particular if two variables want to
   access each other, you can end up into a stall, and freeze your program.
   This can happen more often that one thinks, because a Var may contain a
   {!Layout}, and we know that sometimes layouts want to modify themselves...

{5 {{:graph-b_var.html}Dependency graph}} *)
module Var : sig
  type 'a t

  val create : 'a -> 'a t
  (** [create v] returns a Var with initial value [v]. *)
    
  val get :  'a t ->  'a
    
  val set : 'a t ->  'a -> unit
    (** [set v value] waits until no thread is accessing the Var [v] 
        and then sets its value to [value]. *)
  
end (* of Var *)

(* ---------------------------------------------------------------------------- *)

(** Delayed actions 

{5 {{:graph-b_timeout.html}Dependency graph}}
*)
module Timeout : sig
  type t

  val add : int -> (unit -> unit) -> t
  (** [add delay action] will execute
     [action ()] after the delay of [delay] ms.
     @return the Timeout element. 

     Warning: don't expect the delay to be 
     exact at the ms. The precision cannot be better than what the 
     framerate imposes, {e i.e.} usually about 16ms. *)

  val cancel : t -> unit
    (** Cancel the Timeout. *)
end (* of Timeout *)

(* ---------------------------------------------------------------------------- *)

(** Dealing with events

Events are simply SDL events, plus a few additional events. They are also used
   for primitive communication between threads.

Events are detected by Layouts, and then sent to the resident Widget. Finally,
   the Widget decides what to do with the events. There is one exception: the
   {!startup} event is directly sent to all Widgets.


{5 {{:graph-b_trigger.html}Dependency graph}} *)
module Trigger : sig
  type t = Tsdl.Sdl.event_type

  (** {2 Special Bogue events} *)
         
  val startup : t
  (** The [startup] event is sent to all Widgets when the Bogue mainloop is
     started using {!Main.run}. *)

  val mouse_enter : t
  (** The [mouse_enter] event is triggered when the pointer (mouse motion, or
     finger touch -- but not finger drag) enters a new layout. *)

  val mouse_leave : t
  (** Similar to {!mouse_enter}, when the pointer leaves the layout. *)

  val var_changed : t
  (** The [var_changed] event can be sent to notify that some widget made a
     change to a global variable. *)

  val update : t
  (** Currently the [update] event is more or less equivalent to
     [var_changed]. This might change in future versions. *)

  val buttons_down : t list
  (** A list of events containing the mouse_button_down event, and the
     finger_down event. *)

  val buttons_up : t list
    (** A list of events containing the mouse_button_up event, and the
     finger_up event. *)

  val pointer_motion : t list
  (** A list of events containing the mouse_motion event, and the finger_motion
     event. *)

  (** {2 Using events for terminating threads} *)
    
  val should_exit : Tsdl.Sdl.event -> bool
  (** Tell if the current thread should exit. This should only be called within
     a widget action. The event should be the event passed to the action
     function. A well programmed action should check this event to decide if it
     should exit. *)
  (* à déplacer dans Widget/connection ? *)

  val will_exit : Tsdl.Sdl.event -> unit
  (** A nice thread should do this just before terminating. May be suppressed in
      future versions. *)

  val nice_delay : Tsdl.Sdl.event -> float -> unit
  (** [nice_delay ev t] Wait during a delay ([t] seconds), but quit anyway when
     {!should_exit}[ ev] is true. *)

  val push_quit : unit -> unit
  (** Send the SDL_QUIT event, as if the user clicked on the close button of the
     last existing window. It will in principle raise the {!Main.Exit}
     exception and hence exit the mainloop. *)

  (** {2 SDL events} *)
    
  type sdl_event =
    [ `App_did_enter_background
    | `App_did_enter_foreground
    | `App_low_memory
    | `App_terminating
    | `App_will_enter_background
    | `App_will_enter_foreground
    | `Clipboard_update
    | `Controller_axis_motion
    | `Controller_button_down
    | `Controller_button_up
    | `Controller_device_added
    | `Controller_device_remapped
    | `Controller_device_removed
    | `Dollar_gesture
    | `Dollar_record
    | `Drop_file
    | `Finger_down
    | `Finger_motion
    | `Finger_up
    | `Joy_axis_motion
    | `Joy_ball_motion
    | `Joy_button_down
    | `Joy_button_up
    | `Joy_device_added
    | `Joy_device_removed
    | `Joy_hat_motion
    | `Key_down
    | `Key_up
    | `Mouse_button_down
    | `Mouse_button_up
    | `Mouse_motion
    | `Mouse_wheel
    | `Multi_gesture
    | `Quit
    | `Sys_wm_event
    | `Text_editing
    | `Text_input
    | `Unknown of int
    | `User_event
    | `Window_event]

  type bogue_event =
    [ `Bogue_startup
    | `Bogue_stop
    | `Bogue_stopped
    | `Bogue_mouse_at_rest
    | `Bogue_full_click
    | `Bogue_mouse_enter
    | `Bogue_mouse_leave
    | `Bogue_var_changed
    | `Bogue_keyboard_focus
    | `Bogue_mouse_focus
    | `Bogue_update
    | `Bogue_sync_action
    | `Bogue_redraw ]

  val event_kind : Tsdl.Sdl.event -> [sdl_event | bogue_event]
  (** Union of {!sdl_event} and {!bogue_event} *)
    
end (* of Trigger *)

(* ---------------------------------------------------------------------------- *)

(** Basic audio mixer for sound effects

This simple audio mixer makes it possible to play quick sounds, for instance
   when clicking on buttons, or for game sounds effects.

Only WAV files are supported. For playing MP3 music, and for more options, it is
   advisable to use the SDL_Mixer library.

{e Remark:} This module is essentially independent of the rest of Bogue, so its
   source can, with very few modifications, be used for any SDL application.

{5 {{:graph-b_mixer.html}Dependency graph}} *)
module Mixer : sig
  type t
  type sound =  (int, Bigarray.int16_signed_elt) Tsdl.Sdl.bigarray
  type repeat = Repeat of int | Forever
  (* How many times we should repeat the sound. *)
  
  val test : unit -> unit

  val init : unit -> string option
  (** Initialize SDL audio. 
      @return the name of the audio driver. *)

  val create_mixer : ?tracks:int -> ?freq:int -> string option -> t
  (** Create the mixer an open sound device. Only [s16le] format is supported by
      the callback at this time. *)

  val load_chunk : t -> string -> sound
  (** Load a WAV file. *)

  val play_chunk : ?track:int ->
    ?effects:(sound -> unit) list ->
    ?volume:float -> ?repeat:repeat -> t -> sound -> int option
  (** Play chunk on the desired track number. If [track] is not specified, find
     an available track. By default [repeat = Repeat 1].
     @return chosen track number, or None *)
  
  val change_volume : float -> sound -> unit
  (** Multiply sound intensity by a float factor *)

  val pause : t -> unit
  val unpause : t -> unit
  val close : t -> unit

end (* of Mixer *)

(* ---------------------------------------------------------------------------- *)

(** Synchronized execution queue.

   Any action can be pushed to this FIFO queue, in order to be executed by
   Bogue's main loop at the start of the next graphical frame.

   For any action that is not super urgent, it is a good idea to use this `Sync`
   module, instead of launching the action directly from a thread that may be
   difficult to control. In this way, we ensure that the action is not executed
   in the middle of rendering the graphics, or between various modifications of
   the board (events, keyboard focus, etc.).

{5 {{:graph-b_sync.html}Dependency graph}} *)
module Sync : sig

  val push : (unit -> unit) -> unit
(** [push action] registers the [action] to be executed by the mainloop at the
   start of the next frame, or at a subsequent frame if the queue is already
   large. *)
    
end (* of Sync *)

(* ---------------------------------------------------------------------------- *)

(** Low-level graphics and colors

This module is internally used for low-level graphics and a thin layer over Tsdl.

The public API is mainly useful for Color management.

{5 {{:graph-b_draw.html}Dependency graph}}
*)
module Draw: sig
  type canvas
  (** Contains the hardware information for drawing (SDL renderer and window). *)
     
  type texture = Tsdl.Sdl.texture

  (** {2 Initialization and shutdown} *)

  val quit : unit -> unit
  (** Cleanup and quit SDL. *)
    
  (** {2 Colors} *)

  type rgb = int * int * int
  (** red, green and blue values are integers in the range [0..255] *)

  type color = int * int * int * int
  (** r,g,b,a *)

  type fill =
    | Pattern of texture
    | Solid of color

  (** {3 Predefined colors} *)
             
  val black : rgb
  val grey : rgb
  val pale_grey : rgb
  val dark_grey : rgb
  val white : rgb
  val red : rgb
  val blue : rgb
  val green : rgb
  val magenta : rgb
  val cyan : rgb
  val yellow : rgb
  val sienna : rgb

  val label_color : rgb
    
  val none : color
  (** [none = (0,0,0,0)] is completely transparent black. *)

  (** {3 Creating colors} *)
    
  val opaque : rgb -> color
  val transp : rgb -> color
  val lighter : color -> color
  val darker : color -> color
  val set_alpha : int -> rgb -> color
  val find_color : string -> rgb
  (** Convert a string of the form ["grey"] or ["#FE01BC"] to a rgb code
     [(r,g,b)]. Color names are taken from
     {{:https://www.rapidtables.com/web/color/html-color-codes.html}here}. *)

  val pale : rgb -> rgb

  (** {3 Using colors} *)

  val set_color : Tsdl.Sdl.renderer -> color -> unit
  (** Equivalent to [Sdl.set_render_draw_color]. *)
    
  (** {2 Layers} *)

  (** Layers are used to decide the order of drawing: which graphical elements
     (layouts) should be below, which should be above. For the most part, you
     don't have to access them directly. *)
  type layer

  val use_new_layer : unit -> unit
  (** Use this when you want to switch to a completely different set of layers,
      typically when you want to draw on another window. *)

  (** {2 Misc} *)
    
  type align =
    | Min
    | Center
    | Max
    
  val unscale_size : int * int -> int * int
  (** Transform a size (W,H) in physical pixels into 'logical' pixels (w,h),
     which are used for layouts. This is done by dividing by the {!Theme}
     [SCALE] variable. *)     
    
  val set_system_cursor : Tsdl.Sdl.System_cursor.t -> unit
  (** Set the mouse cursor to be the standard system cursor.  Internally, this
      first creates an SDL system cursor (or use a previously created one). *)
    
end (* of Draw *)

(* ---------------------------------------------------------------------------- *)

(** Mouse and touchscreen information

All positions are given in logical pixels, not hardware pixels (see the {!Theme}
   [SCALE] variable).

{5 {{:graph-b_mouse.html}Dependency graph}} *)
module Mouse : sig

  val pointer_pos : Tsdl.Sdl.event -> int * int
  (** Return the pointer current position. This works both for mouse and
     touchscreen. *)

  val pos : unit -> int * int
  (** Get current mouse position. *)

  val window_pos : Tsdl.Sdl.window -> int * int
(** Return the mouse position with respect to the given window, using window
   position if necessary. *)

  val button_pos : Tsdl.Sdl.event -> int * int

  val finger_pos : Tsdl.Sdl.event -> float * float

    
end (* of Mouse *)

(* ---------------------------------------------------------------------------- *)

  
(** Transform variables

    Transform variables are a way to share a common data between two widgets,
   when the data has a different meaning (or even a different type) for each
   widget. One widget holds the original value, and the other widget needs to
   apply a {e transformation} each time it wants to read or modify the value.

    For instance you want to share a bank account [b] between Alice in France
   and Bob in the USA. The value is stored by Alice in EUR, and when Bob does
   [get b], he gets the value in USD. Similarly, if he does [set b 50] to put
   50USD on the account, then Alice's value will automatically have the amount
   in EUR.

    What is interesting is that the transformation functions can also have {e
   side-effects}. For instance, send an email each time Bob or Alice modifies
   the amount.

    A more prosaic example would be a slider which shares its value as an
   integer between 0 and 100, and another widget which needs to read/save this
   value as a float between 0 and 1, and each one of them gets notified when the
   other changes the value.

{5 {{:graph-b_tvar.html}Dependency graph}} *)
module Tvar : sig
  type ('a, 'b) t
  (** a transform variable of type [('a,'b)] is a variable of type ['b] attached to
     a variable of type ['a Var.t] by a bi-directional transformation. *)
      
end (* of Tvar *)

(* ---------------------------------------------------------------------------- *)

(** Animated variables

    An Avar.t is a variable that evolves in time. It is updated at every frame
   ({e i.e.} every iteration of the main loop). Bogue uses Avars for animations.

{5 {{:graph-b_avar.html}Dependency graph}} *)
module Avar : sig
  type 'a t

  type callback = unit -> unit
  
  (** {2 Avar creation} *)

  val create : ?duration:Time.t ->
    ?init:callback ->
    ?ending:callback ->
    ?finished:bool -> ?update:('a t -> float -> 'a) -> 'a -> 'a t
  (** Generic Avar creation. If [finished = true], the var never gets further
     updated, {e ie} behaves like a normal variable. Otherwise, the [update]
     parameter is compulsory.

     @param update is a function such that [update v s : 'a] should give the
     value of the Avar [v] at the time [s]. The meaning of the time [s] is
     described in {!progress}. *)
      
  val fromto : ?duration:int -> ?ending:callback -> int -> int -> int t
  (** [fromto x1 x2] creates a integer Avar.t with initial value [x1] and, as
      time elapses, moves continuously to [x2], with a final slowdown. *)

  (** {2 Avar information} *)
    
  val progress : 'a t -> float
  (** [progress v] is a float in [0,1] giving the percentage of the animation
     when the last [v.value] was computed. In case of infinite animation, this
     is just the elapsed Time (in ms). *)

  (** {2 Misc} *)

  type direction =
    | No
    | Left
    | Right
    | Top
    | Bottom
    | TopLeft
    | TopRight
    | BottomLeft
    | BottomRight
    | Random
end (* of Avar *)

(* ---------------------------------------------------------------------------- *)

(** Unions of ranges of integers

{5 {{:graph-b_selection.html}Dependency graph}}
 *)
module Selection : sig
  type t
    
end (* of Selection *)

(* ---------------------------------------------------------------------------- *)

(** {2 Widgets}

    Widgets are building blocks of the GUI. They also receive all events (mouse
   focus, etc.) and contain the {e intelligence} of your GUI, through {e
   connections} (or callbacks, see {!Widget.connection}). However, in order to
   be displayed, they need to be packed into {e layouts} ({!Layout.t}). *)

(** Image widget

{5 {{:graph-b_image.html}Dependency graph}}
 *)
module Image : sig
  type t

  val create : ?width:int -> ?height:int -> ?noscale:bool -> ?bg:Draw.color -> string -> t
  (** [create "image.jpg"] will load the image ["image.jpg"]. The actual load
     occurs only once, on the first time the image widget is effectively
     displayed. The image is then stored in a texture. All
     {{:https://www.libsdl.org/projects/SDL_image/}Sdl_image} image formats are
     supported.

     The file "image.png" will be search in the current Theme
     directory. Absolute paths starting with "/" can also be used.

   @param noscale if [true], the image will appear at the original hardware
     pixel size. By default, [noscale=false] and the image is scaled using the
     {!Theme} [SCALE] variable. *)

  val create_from_svg : ?width:int -> ?height:int -> ?bg:Draw.color -> string -> t
(** Load an svg image. This requires the [rsvg] or [rsvg-convert] program.

    {e Remark:} With SDL_Image >= 2.0.2, one can use {!create} to load SVG
   files, but the size is not correctly handled (the image will be rendered at
   its 'internal SVG size', and {e then} scaled, which may result in poor
   accuracy).

   *)
    
end (* of Image *)

(* ---------------------------------------------------------------------------- *)

(** Line and box styles

{5 {{:graph-b_style.html}Dependency graph}}
 *)
module Style : sig
  type line_style = (* not implemented *)
    | Solid
    | Dotted of (int * int)
  type line
  type border
  type shadow
  type gradient
  type background =
  | Image of Image.t (* pattern image *)
  | Solid of Draw.color
  | Gradient of gradient

  val color_bg : Draw.color -> background
  val gradient : ?angle:float -> Draw.color list -> background
  val hgradient : Draw.color list -> background
  val vgradient : Draw.color list -> background
  val line : ?color:Draw.color -> ?width:int -> ?style:line_style -> unit -> line
  val border : ?radius:int -> line -> border
  val shadow : ?offset:int * int -> ?size:int -> ?width:int -> ?radius:int -> unit -> shadow
end (* of Style *)

(* ---------------------------------------------------------------------------- *)

(** One-line text widget

A [Label] is a widget for displaying a single line of text.
 
{5 {{:graph-b_label.html}Dependency graph}}
 *)
module Label : sig
  type t
  type font

  val create : ?size:int -> ?font:font -> ?style:Tsdl_ttf.Ttf.Style.t ->
               ?fg:Draw.color -> string -> t
  (** Create a new {!Label.t}. Most of the time, you'd rather want to create a
     {!Widget.t} by using {!Widget.label}. *)

  val icon : ?size:int -> ?fg:Draw.color -> string -> t
  (** Create a {!Label.t} using the name of a
     {{:https://lab.artlung.com/font-awesome-sample/}FontAwesome} symbol.  Most
     of the time, you'd rather want to create a {!Widget.t} by using
     {!Widget.icon}. *)
    
  val set : t -> string -> unit
  (** Modify the text of the label. *)

  val set_fg_color : t -> Draw.color -> unit
  (** Modify the color of the text. *)
    
  val size : t -> int * int
  (** Return the logical size (w,h). 
      Warning, a +/- 1 error can be observed due to rounding. *)
    
end (* of Label *)

(* ---------------------------------------------------------------------------- *)

(** Button widget with text or icon 

{5 {{:graph-b_button.html}Dependency graph}}
*)
module Button : sig
  type t
  type kind =
    | Trigger (* one action when pressed. TODO, better to avoid name clash with
                 Trigger module*)
    | Switch (* two states *)

  val state : t -> bool
  val reset : t -> unit
  val is_pressed : t -> bool
end (* of Button *)

(* ---------------------------------------------------------------------------- *)

(** Slider widget

{5 {{:graph-b_slider.html}Dependency graph}}
 *)
module Slider : sig
  type t
  type  kind =
    | Horizontal (* horizontal bar with a small slider; NO background *)
    | HBar (* horizontal bar filled up to the value *)
    | Vertical
    | Circular 

  val size : t -> int * int
             
  val value : t -> int
  (** Get current value. *)

  val set : t -> int -> unit
  (** Set a new value. *)
    
end (* of Slider *)

(* ---------------------------------------------------------------------------- *)

(** Checkbox widget

{5 {{:graph-b_check.html}Dependency graph}}
 *)
module Check : sig
  type t
  type style

  val create :  ?state:bool -> ?style:style -> unit -> t
end (* of Check *)

(* ---------------------------------------------------------------------------- *)

(** Multi-line text display widget

{5 {{:graph-b_text_display.html}Dependency graph}}
 *)
module Text_display : sig
  type t
  type words

  (** {2 Preparing the text} *)
    
  val example : words
  val raw : string -> words
  val bold : words -> words
  val italic : words -> words
  val normal : words -> words
  val underline : words -> words
  val strikethrough : words -> words
  val page : words list -> words list
  val para : string -> words
  val paragraphs_of_string : string -> words list
    
  (** {2 Creating the widgets} *)

  (** {2 Modifying the widgets} *)
    
  val update_verbatim : t -> string -> unit
    
end (* Text_display *)

(* ---------------------------------------------------------------------------- *)

(** One-line text-input widget

{5 {{:graph-b_text_input.html}Dependency graph}}
 *)
module Text_input : sig
  type t
  type filter = string -> bool

  val uint_filter : filter
  val text : t -> string
    
end (* of Text_input *)

(* ---------------------------------------------------------------------------- *)

(** Box widget 

{5 {{:graph-b_box.html}Dependency graph}}
*)
module Box : sig
  type t

  val create : ?width:int -> ?height:int ->
               ?background:Style.background -> ?border:Style.border ->
               ?shadow:Style.shadow -> unit -> t
    
end (* of Box *)

(* ---------------------------------------------------------------------------- *)

(** Creating widgets and giving life to them

Widgets are simple graphic elements that can react to user interaction. They are
   the inhabitants of your GUI house. When a widget is woken up by some event,
   it can talk to another widget by means of a [connection].

{5 {{:graph-b_widget.html}Dependency graph}} *)
module Widget : sig
  type t
  (** The type {!t} is a union of all kinds of widgets: Box, Button, Check box,
     Image, Label, Slider, Text display, and Text input, plus the Empty
     widget. 

For instance, in the following code:
{[
let w = label "Hello" in
let l = get_label w in
...
]}
[w] has the generic {!t} type, while [l] has the specialized {!Label.t} type.
*)
     
  (** {2:connections Connections}

      A connection has a source widget and a target widget. When the source
     widget receives a specified event, the connection is activated, executing a
     specified function, which is called {!action}.

     An action is always executed in a new Thread (and hence will not block the
     GUI), unless the priority [Main] is specified.  *)
     
  type connection
     
  type action = t -> t -> Tsdl.Sdl.event -> unit
  (** An action is a function with three parameters [w1 w2 ev], where
     [w1] is the source widget, [w2] the target widget, and [ev] the event
     ({!Trigger.t}) that triggered the action. *)
              
  (** What to do when the same action (= same connection id) is already running? *)
              
  type action_priority = 
    | Forget (** discard the new action *)
    | Join (** execute the new after the first one has completed *)
    | Replace (** kill the first action (if possible) and execute the second one
                 *)
    | Main (** run in the main program. So this is blocking for all subsequent
              actions *)  

  val connect : t -> t -> action ->
    ?priority:action_priority ->
    ?update_target:bool -> ?join:connection -> Trigger.t list -> connection
  (** [connect source target action triggers] creates a connection from the
     [source] widget to the [target] widget, but does not register it ({e this
     may change in the future...}). Once it is registered (either by
     {!Main.make} or {!add_connection}), and assuming that the layout containing
     the source widget has {e focus}, then when an event [ev] matches one of the
     [triggers] list, the [action] is executed with arguments [source target
     ev].

     @param priority indicates the desired priority policy. Default is [Forget].

*)

  val connect_main : t -> t -> action ->
    ?update_target:bool -> ?join:connection -> Trigger.t list -> connection
  (** Alias for [connect ~priority:Main]. Should be used for very fast actions
     that can be run in the main thread. *)
    
  val add_connection : t -> connection -> unit
  (** Registers the connection with the widget. This should systematically be
     done after each connection creation, when the connection is created {e
     after} {!Main.make}.

     Connections that are created {e before} {!Main.make} should rather be
     passed as argument to {!Main.make}, and {e not} via
     [add_connection]. Although this is not striclty necessary, this indicates
     that these connections are more 'pure' or at least more static, in the
     sense that they will not be modified by Bogue. These are usually much
     easier to debug.

     {e [add_connection] is separated from {!connect} because it is not pure: it
     mutates the widget. This might change in future versions.} *)
    
  val update : t -> unit
  (** [update w] asks the widget [w] to refresh at next frame. The most probable
     use of [update] is within the code of an {!action}. It can happen that the
     action modifies the visual state of a widget that is neither the source or
     the target, and then one needs to explicitly tell this widget to re-draw
     itself.  *)

  (** {3 Predefined connections} *)

  val on_release : release:(t -> unit) -> t -> unit
  (** [on_release ~release:f w] registers on the widget [w] the action [f],
     which will be executed when the mouse button is released on this widget. 
      {e Uses [priority=Main]} *)

  val on_click : click:(t -> unit) -> t -> unit
  (** {e Uses [priority=Main]} *)

  val mouse_over : ?enter:(t -> unit) -> ?leave:(t -> unit) -> t -> unit

  
  (** {2:widget_create Creation of Widgets} *)
    
  (** {3 Simple boxes (rectangles)} *)
    
  val box :
    ?w:int -> ?h:int ->
    ?background:Style.background -> ?border:Style.border ->
    ?shadow:Style.shadow -> unit -> t
  (** Create a Box widget, which simply displays a rectangle, optionally with
     rounded corners and drop shadow. It is often used for the background of a
     group of widgets (i.e. a {!Layout.t}). *)

  (** {3 Check boxes}
      The standard on/off check boxes. *)
    
  val check_box : ?state:bool -> ?style:Check.style -> unit -> t
  val set_check_state : t -> bool -> unit

  (** {3 Text display}
      Use this for multi-line text. *)

  val text_display :  ?w:int -> ?h:int -> string -> t
  val rich_text : ?size:int -> ?w:int -> ?h:int -> Text_display.words list -> t
  val verbatim : string -> t
    
  (** {3 Labels or icons} *)

  val label : ?size:int -> ?fg:Draw.color -> ?font:Label.font -> string -> t
  (** Create a Label widget with a one-line text. *)
    
  val icon : ?size:int -> ?fg:Draw.color -> string -> t
  (** Create a Label widget with a
     {{:https://lab.artlung.com/font-awesome-sample/}FontAwesome} icon.

     For instance [icon ~size:24 "star"] creates a widget that displays the
     "fa-star" fontawesome icon. *)                                         
  
  (** {3 Empty} *)

  val empty : w:int -> h:int -> unit -> t
  (** Create a widget that does not display anything but still gets focus and
     reacts to events. *)
    
  (** {3 Image} *)

  val image : ?w:int -> ?h:int -> ?bg:Draw.color ->
    ?noscale:bool -> string -> t
  (** Load image file. *)
    
  val image_from_svg : ?w:int -> ?h:int -> ?bg:Draw.color -> string -> t
  (** Requires [rsvg]. *)
    
  (** {3 Text input} *)
    
  val text_input : ?text:string -> ?prompt:string ->
    ?size:int -> ?filter:Text_input.filter -> ?max_size:int -> unit -> t

  (** {3 Buttons} *)

  val button : ?kind:Button.kind -> ?label:Label.t ->
    ?label_on:Label.t -> ?label_off:Label.t ->
    ?fg:Draw.color ->
    ?bg_on:Style.background -> ?bg_off:Style.background ->
    ?bg_over:Style.background ->
    ?state:bool ->
    ?border_radius:int -> ?border_color:Draw.color -> string -> t
    
  (** {3 Sliders} *)

  val slider : ?priority:action_priority -> ?step:int -> ?value:int ->
    ?kind:Slider.kind ->
    ?var:(int Avar.t, int) Tvar.t ->
    ?length:int -> ?thickness:int -> ?tick_size:int -> ?lock:bool -> int -> t

  val slider_with_action : ?priority:action_priority ->
    ?step:int -> ?kind:Slider.kind -> value:int -> ?length:int ->
    ?thickness:int -> ?tick_size:int -> action:(int -> unit) -> int -> t
  (** Create a slider that executes an action each time the local value of the
     slider is modified by the user. *)
  
  (** {2 Creation of combined widgets} *)

  val check_box_with_label : string -> t * t
  (** [let b,l = check_box_with_label text] creates a check box [b], a label
     [l], and connect them so that clicking on the text will also act on the
     check box. *)

  (** {2 Generic functions on widgets} *)
    
  val get_state : t -> bool
  (** query a boolean state. Works for Button and Check. *)

  val get_text : t -> string
  (** Return the text of the widget. Works for Button, TextDisplay, Label,
     and TextInput. *)
  
  val set_text : t -> string -> unit
  (** Change the text of a widget. Works for Button, TextDisplay, Label,
     and TextInput. *)

  (** {2 Conversions from the generic Widget type to the specialized inner type}
     *)

  val get_box : t -> Box.t
  val get_check : t -> Check.t
  val get_label : t -> Label.t
  val get_button : t -> Button.t
  val get_slider : t -> Slider.t
  val get_text_display : t -> Text_display.t
  val get_text_input : t -> Text_input.t
end (* of Widget *)

(* ---------------------------------------------------------------------------- *)

(** Updating widgets

{5 {{:graph-b_update.html}Dependency graph}}
*)
module Update : sig

  val push : Widget.t -> unit
  (** Register a widget for being updated (at next frame) by the main loop. *)
    
end (* of Update *)

(* ---------------------------------------------------------------------------- *)


(** {2 Layouts}

    Layouts are rectangular graphical placeholders, in which you should pack all
   your widgets in order to display your GUI. Sophisticated gadgets are usually
   obtained by combining several layouts together.  *)


(** The main, all-purpose graphics container

 A layout is a "box" (a rectangle) whose purpose is to place onscreen the
   various elements composing the GUI. It can contain a single widget, or a list
   of sub-layouts. In Bogue, we use the housing metaphor: a layout is a {b
   house} that contains either a single {b resident}, or several {b rooms}. Each
   room can be seen as a sub-house, and can contain a resident or
   sub-rooms. Houses and rooms have the type {!t}, while a resident has the type
   {!Widget.t}.

     Technically, the usual metaphor in computer science is a {e Tree}. A layout
   is a tree, each vertex (or node) has any number of branches (or children). A
   leaf (terminal node: without any child) is either empty or contains a
   widget. However, the tree is upside-down (as often): we think of the trunk
   (or {e top-layout}) to be a the top, and the leaves at the bottom.

{5 {{:graph-b_layout.html}Dependency graph}} *)
module Layout : sig
  type t

  exception Fatal_error of (t * string)
    
  type room_content =
    | Rooms of t list
    | Resident of Widget.t
                    
  (** Not implemented. *)
  type adjust   =
  | Fit
  | Width
  | Height
  | Nothing

  (** {2 Backgrounds} *)

  (** Warning, there is also {!Style.background}... Maybe this will change in the
      future. *)
  type background

  val color_bg : Draw.color -> background

  val box_bg : Box.t -> background

  val bg_color: background
    (** This is the value of the current theme's BG_COLOR. *)

  val unload_background : t -> unit
  (** Free the texture associated with the background (if any). This can be used
     to force recreating it. *)
  
  (** {2 Creation of layouts}

      Remark: all layouts have an optional [name] property, which is used only
     for debugging. *)

  val empty : ?name:string -> ?background:background -> w:int -> h:int -> unit -> t
  (** An empty layout can reserve some space without stealing focus. *)
     
  (** {3 Create layouts from widgets} *)
    
  val resident :
    ?name:string -> ?x:int -> ?y:int -> ?w:int -> ?h:int ->
    ?background:background ->
    ?draggable:bool ->
    ?canvas:Draw.canvas ->
    ?layer:Draw.layer -> ?keyboard_focus:bool -> Widget.t -> t
  val flat_of_w :
    ?name:string -> ?sep:int -> ?h:int ->
    ?align:Draw.align ->
    ?background:background ->
    ?widget_bg:background -> ?canvas:Draw.canvas -> Widget.t list -> t
  val tower_of_w :
    ?name:string -> ?sep:int ->
    ?align:Draw.align ->
    ?background:background -> 
    ?widget_bg:background -> ?canvas:Draw.canvas -> Widget.t list -> t

  (** {3 Create layouts from other layouts} *)
    
  val flat :
    ?name:string -> ?sep:int ->
    ?adjust:adjust -> ?hmargin:int -> ?vmargin:int -> ?margins:int ->
    ?align:Draw.align ->
    ?background:background -> ?shadow:Style.shadow ->
    ?canvas:Draw.canvas -> t list -> t
  val tower :
    ?name:string -> ?sep:int ->
    ?margins:int -> ?hmargin:int -> ?vmargin:int ->
    ?align:Draw.align ->
    ?adjust:adjust ->
    ?background:background -> ?shadow:Style.shadow ->
    ?canvas:Draw.canvas -> t list -> t
  val superpose : ?w:int -> ?h:int -> ?name:string ->
    ?background:background -> ?canvas:Draw.canvas -> t list -> t
  (** Create a new layout by superposing a list of layouts without changing
      their (x,y) position. *)

  (** {2 Some useful layout combinations} *)
    
  val make_clip : ?w:int ->
    ?scrollbar:bool ->
    ?scrollbar_inside:bool -> ?scrollbar_width:int -> h:int -> t -> t
  (** Clip a layout inside a smaller container and make it scrollable, and
      optionally add a scrollbar widget. *)
  
  (** {2 Get layout attributes} *)

  val xpos : t -> int
  (** get current absolute x position of the layout (relative to the top-left
      corner of the window) *)

  val ypos : t -> int
  (** see {!xpos} *)

  val width : t -> int
  val height : t -> int
  val get_size : t -> int * int
  (** [get_size l] is equivalent to [(width l, height l)] *)

  val get_physical_size : t -> int * int
  (** multiplies [get_size] by the Theme scaling factor. This gives in principle
     the correct size in physical pixels, up to an error of +/- 1pixel, due to
     rounding error. *)

  val getx : t -> int
  (** Compute the relative x position of the room with respect to its house,
     using animations if any. Because of this, this function should not be
      called by the animation itself! Use {!get_oldx} instead.  *)

  val get_oldx : t -> int
  (** Return the last computed value for the relative x position of the
     layout. *)

  val gety : t -> int
  val get_oldy : t -> int
    
  val widget : t -> Widget.t
  (** Return the resident widget, or 
      @raise Not_found if the layout is not a {e leaf}. *)

  val top_house : t -> t
  (** Return the top of the layout tree (the "house" that contains the given
     layout and that is not contained in another layout). It is the only layout
     that is directly attached to a "physical" (SDL) window. *)

  val get_content : t -> room_content
  
  (** {2 Modify existing layouts}

      These functions will not work if there is an animation running acting of the
     variable we want to set. *)

  val set_width : ?update_bg:bool -> t -> int -> unit
  val set_height : t -> int -> unit
  val setx : t -> int -> unit
  val sety : t -> int -> unit
  val set_show : t -> bool -> unit

  val set_shadow : t -> Style.shadow option -> unit
    
  val fit_content : ?sep:int -> t -> unit
  (** Adapt the size of the layout (and their houses) to the disposition of the
     contained rooms. *)

  val set_rooms : t -> ?sync:bool -> t list -> unit
  (** Modify the layout content by replacing the former content by a new list of
     rooms. Use [sync=true] (the default) as much as possible in order to avoid
     multi-threading problems. Then the changes will be applied by the main
      thread at next frame (see {!Sync}). *)

  val unload_textures : t -> unit
  (** Use this to free the textures stored by the layout (and its children) for
     reducing memory. The layout can still be used without any impact, the
     textures will be recreated on the fly.  *)
    
  val lock : t -> unit
  val unlock : t -> unit
  (** Since layouts can be modified by different threads, it might be useful to
     lock it with a mutex. This does *not* always prevent from modifying it, but
     another [lock] statement will wait for the previous lock to be removed by
     {!unlock}. *)
    
  
  (** {2 Animations}

      Position, size, alpha channel, and rotation of Layouts use [Avar]
     variables and hence can be easily animated. Most predefined animations have
      a default duration of 300ms. *)

  (** {3 Generic animations}

      These functions assign an animated variable if type {!Avar.t} to one
     of the properties of the layout (position, width, etc.)  *)
    
  val animate_x : t -> int Avar.t -> unit
  (** Assign an Avar to the layout x position. *)

  val animate_y : t -> int Avar.t -> unit
  val stop_pos : t -> unit
  (** Stop animations of the variables x and y. *)

  val animate_w : t -> int Avar.t -> unit
  val animate_h : t -> int Avar.t -> unit
  val animate_alpha : t -> float Avar.t -> unit
  val animate_angle : t -> float Avar.t -> unit
    
  (** {3 Predefined animations} *)
    
  val hide : ?duration:int -> ?towards:Avar.direction -> t -> unit
  (** See {!show}. *)

  val show : ?duration:int -> ?from:Avar.direction -> t -> unit
  (** Does nothing if the layout is already fully displayed. Only the
     [Avar.Top] and [Avar.Bottom] directions are currently implemented. For
     these directions, [hide] and [show] do {e not} modify the position
     variables (x,y) of the layout, they use a special variable called
     [voffset]. *)

  val fade_in : ?duration:int -> ?from_alpha:float -> ?to_alpha:float ->
    t -> unit
  (** Animate the alpha channel of the layout. Can be combined with animations
     involving the other animated variables. Does {e not} modify the [show]
     status of the layout. By default, [from_alpha=0.] (transparent) and
      [to_alpha=1.]  (opaque).  *)

  val fade_out : ?duration:int ->
    ?from_alpha:float -> ?to_alpha:float -> ?hide:bool -> t -> unit
  (** See {!fade_in}. WARNING: fading out to alpha=0 results in a completely
     transparent layout, but the layout is {e still there} (it's not
     "hidden"). Which means it can still get mouse focus. If you want to hide
     it, then use [hide=true]. By default, [hide=false], [from_alpha] is the
     current alpha of the layout, and [to_alpha=0.] *)

  val rotate : ?duration:int -> ?from_angle:float -> angle:float -> t -> unit
  (** Rotate all widgets inside the layout around their respective centers. For
      a global rotation, use a {!Snapshot}. *)
    
  val slide_in : ?from:Avar.direction -> dst:t -> t -> unit
  val slide_to : ?duration:int -> t -> int * int -> unit
  (** [slide_to room (x0,y0)] will translate the [room] to the position
     [(x0,y0)]. *)

  val follow_mouse : ?dx:int -> ?dy:int ->
    ?modifierx:(int -> int) -> ?modifiery:(int -> int) -> t -> unit
  val oscillate : ?duration:int -> ?frequency:float -> int -> t -> unit
  val zoom : ?duration:int -> from_factor:float -> to_factor:float -> t -> unit

  val reflat : ?align:Draw.align ->
    ?hmargin:int -> ?vmargin:int -> ?margins:int -> ?duration:int -> t -> unit
  (** Adjust an existing layout to arrange its rooms in a "flat" fashion, as if
     they were created by {!Layout.flat}. Will be animated if [duration <> 0]. *)

  val retower : ?align:Draw.align ->
    ?hmargin:int -> ?vmargin:int -> ?margins:int -> ?duration:int -> t -> unit
    
  (** {2 Windows}

      A very special use of layout is to represent the 'window' on which
     everything is drawn. Thus, this specific to the 'main house' (or {e
     top-layout}), {e i.e.} a layout that is not a sublayout of another
     layout. *)

  val window : t -> Tsdl.Sdl.window
                         
  val set_window_pos : t -> int * int -> unit
  (** It should be set {b after} {!Main.make} and {b before}
     {!Main.run}. Otherwise it has possibly no effect, or perhaps causes some
      glitches.  *)

  (** {2 Misc} *)

  val set_cursor : t option -> unit
  (** Sets the cursor to the default value for this layout. *)
    
end (* of Layout *)

(* ---------------------------------------------------------------------------- *)

(** Adjust various spacings and sizes of layouts

These functions {e do not take effect immediately!} They will be executed, in
   the order of their invocation, at the next graphics frame (or at startup if
   they are invoked before the start of the mainloop).  

{5 {{:graph-b_space.html}Dependency graph}}
*)
module Space : sig

  
  val hfill : ?margin:int -> unit -> Layout.t
  (** When used in a {!Layout.flat} structure, this special empty layout will
     automatically expand in order to fill the available width in the parent
     house. *)

  val vfill : ?margin:int -> unit -> Layout.t
  (** When used in a {!Layout.tower} structure, this special empty layout will
     automatically expand in order to fill the available height in the parent
     house. *)

  val full_width : ?margin:int -> Layout.t -> unit
  (** This will set the width of the room (layout) in order to occupy the whole
     width of its house. *)

  val make_hfill : ?margin:int -> Layout.t -> unit
  (** Like {!hfill}, but applies to the specified layout instead of creating an
      empty one. *)

  val make_vfill : ?margin:int -> Layout.t -> unit
    
  val vcenter : Layout.t -> unit
  (** Will vertically center the layout in its house. *)
end (* of Space *)

(* ---------------------------------------------------------------------------- *)

(** Convert Bogue objects to strings for debugging 

{5 {{:graph-b_print.html}Dependency graph}}
*)
module Print : sig

  val layout_down : ?indent:string -> Layout.t -> string
  (** Print a layout with all its rooms and subrooms (children). *)

  val layout_up : ?indent:string -> Layout.t -> string
  (** Print the layout node and all the rooms (houses, or parents) in which it
      is contained. *)

  val layout_error : Layout.t -> string -> unit
  (** Print a message to stderr and dump the top_house structure to a temporary
     file. *)
    
end (* of Print *)

(* ---------------------------------------------------------------------------- *)

(** Create an image from a Layout 

{5 {{:graph-b_snapshot.html}Dependency graph}}
*)
module Snapshot : sig

  val create : ?border:Style.border -> Layout.t -> Widget.t
  (** Should be called from the main thread only. There are some issues with
     transparency. 
     @return a Box widget. *)
                                                                   
end (* of Snapshot *)

(* ---------------------------------------------------------------------------- *)

(** Handle large lists by not displaying all elements at once

Very quickly, displaying a list of layouts (for instance, listing files in a
   directory) can run the computer out of memory if it tries to keep in memory
   the textures of {b all} entries of the list. In these cases you need to use a
   [Long_list].

See for instance the example 34: `boguex 34` that displays a list of 1 million
   entries.

Long_lists may contain any type of Layout. They don't need to be all of the same
   dimension. Instead of providing the list of layouts, one must give a function
   [generate] such that the layout given by [generate i] is the i-eth element of
   the list.

{5 {{:graph-b_long_list.html}Dependency graph}} *)
module Long_list : sig
  type t

  val create : w:int -> h:int -> length:int ->
    ?first:int ->
    generate:(int -> Layout.t) ->
    ?height_fn:(int -> int option) ->
    ?cleanup:(Layout.t -> unit) ->
    ?max_memory:int ->
    ?linear:bool -> ?scrollbar_width:int -> unit -> Layout.t
  (** Create a long list through the function [generate] which maps any index
     {e i} to the {e ieth} element (layout) of the list. If specified (which is
     not a good idea), the [max_memory] should be at least twice the area (in
     physical pixels) of the visible part of the list. If the number of elements
     is large (typically 100000 or more, this depends on your CPU), its is
     highly advisable to provide a [height_fn], which to an index {e i} gives
     the height (in logical pixels) of the {e ieth} entry. If some heights are
     not known in advance, it's ok to return [None]. For instance, if all
     entries have the same height, say 30 pixels, one can define

      {[ let height_fn _ = Some 30 ]} *)
                                                      
end (* of Long_list *)

(* ---------------------------------------------------------------------------- *)

(** Switch between layouts using Tabs 

{5 {{:graph-b_tabs.html}Dependency graph}}
*)
module Tabs : sig

  val create : 
    ?slide:Avar.direction ->
    ?adjust:Layout.adjust -> ?expand:bool ->
    ?canvas:Draw.canvas ->
    ?name:string -> (string * Layout.t) list -> Layout.t
end (* of Tabs *)

(* ---------------------------------------------------------------------------- *)

(** Put layouts on top of others 

{5 {{:graph-b_popup.html}Dependency graph}} *)
module Popup : sig

  val add_screen : ?color:Draw.color -> Layout.t -> Layout.t
  (** Add a screen on top of the layout. This can be useful to make the whole
     layout clickable as a whole. 
     @return the screen. *)
  
  (** Generic modal type popup *)
  val attach : ?bg:Draw.color ->
    ?show:bool -> Layout.t -> Layout.t -> Layout.t
  (** [attach house layout] adds two layers on top of the house: one for the
     screen to hide the house, one for the layout on top of the screen.
     @return the screen. *)

  val info : ?w:int -> ?h:int -> ?button:string -> string -> Layout.t -> unit
  (** Add to the layout a modal popup with a text and a close button. By
     default, [button="Close"]. *)

  val yesno : ?w:int -> ?h:int ->
    ?yes:string -> ?no:string ->
    yes_action:(unit -> unit) ->
    no_action:(unit -> unit) -> string -> Layout.t -> unit
  (** Add to the layout a modal popup with two yes/no buttons. By default,
      [yes="Yes"] and [no="No"]. *)

  val two_buttons : ?w:int -> ?h:int -> label1:string -> label2:string ->
    action1:(unit -> unit) -> action2:(unit -> unit) ->
    Layout.t -> Layout.t -> unit

  type position =
  | LeftOf
  | RightOf
  | Above
  | Below
  | Mouse

  val tooltip : ?background:Layout.background ->
    ?position:position ->
    string -> target:Layout.t -> Widget.t -> Layout.t -> unit
  (** [tooltip text ~target widget layout] adds a tooltip which will appear on
     [layout], next to [target] (which should be a sublayout of [layout]), when
     the [widget] gets mouse focus and mouse is idle for some time on it. A
     tooltip it not a modal popup, it does not prevent from interacting with the
     rest of the layout. *)
    
end (* of Popup *)

(* ---------------------------------------------------------------------------- *)

(** Various types of menus

The generic {!create} function produces menus whose entries can be arbitrary
   layouts located at arbitrary places. But for usual entries, it is enough to
   provide a string for the entry label, and the layout will be constructed
   automatically.

The specialized {!bar} function will produce a familiar menu bar with drop-down
   submenus.

{5 {{:graph-b_menu.html}Dependency graph}} 
*)
module Menu : sig

  type t
  (* The type of generic menus. *)
  
  type action = unit -> unit
              
  type label =
    | Text of string
    | Layout of Layout.t
              
  type entry = {
      label : label;
      content : content }
             
  and content =
    | Action of action
    | Flat of entry list
    (** A Flat content will produce a horizontal menu *)
    | Tower of entry list
    (** A Tower content will produce a vertical menu *)
    | Custom of entry list
    (** In a Custom content, only Layout labels should be used, and their
       position should be defined before creating the menu. *)
    | Separator
    (** Currently only used for inserting separator lines in Tower menus. *)

  val create : dst:Layout.t -> content -> t
(** Generic menu creation, inserted in the [dst] layout. *)
  
  val bar : dst:Layout.t -> entry list -> unit
  (** Creation of a menu bar in the [dst] layout, with drop-down submenus. [bar
     dst entries] inserts a layout which contains the menu bar into the top of
     the [dst] layout (so, some room should be provided). The [dst] layout
     should be big enough to contain the submenus. Any item flowing out of [dst]
     will not get focus. *)
  
  val separator : entry
    
end

(* ---------------------------------------------------------------------------- *)

(** Drop-down select list

It's the usual select box which opens a drop-down list when clicked on, similar
   to the [<select>] html tag.

 Under the hood, a select list is a special type of menu with a single entry
   having a submenu.

{5 {{:graph-b_select.html}Dependency graph}} *)
module Select : sig

  val create : ?dst:Layout.t ->
    ?name:string ->
    ?action:(int -> unit) ->
    ?fg:Draw.color ->
      string array -> int -> Layout.t
  (** [create string_array i] creates a select box with preselected entry
     [i]. For instance [create [| "A"; "B"; "C" |] 1] will create a select box
     with default choice ["B"]. The [action] (if specified) is executed when an
     item is selected, and takes as argument the index of the selected item.

        @return a layout showing the selected item. *)

end (* of Select *)
     
(* ---------------------------------------------------------------------------- *)

(** Check list with a single choice

    Each item of the list is displayed with a 'radio button' in front of it, and
   at most one item can be selected, similarly to [<input type="radio"...>] in
   html. Radiobuttons are implemented with {!Check.t}. 

{5 {{:graph-b_radiolist.html}Dependency graph}}
*)
module Radiolist : sig
  type t

  val vertical : ?name:string -> ?click_on_label:bool -> ?selected:int -> string array -> t
  (** A radiolist with the usual vertical layout of items. The option [click_on_label] is true be default: one can click on the label to select it. *)

  val layout : t -> Layout.t
  (** The layout to display the radiolist. *)

  val get_index : t -> int option
  val set_index : t -> int -> unit
  (** Set the selected entry to the specified index and directly activate the
     button's connections with the {!Trigger.var_changed} event. *)

  val active_widgets : t -> Widget.t list
  (** @return the list of widgets that are active for selecting entries ({e
     i.e.} either radiobuttons or radiobuttons and labels, depending on
     [click_on_label]. *)
end (* of Radiolist *)

(* ---------------------------------------------------------------------------- *)

(** Tables with sortable columns and selectable rows 

{5 {{:graph-b_table.html}Dependency graph}}
*)
module Table : sig
  type column =
    { title : string;
      length : int;
      rows : int -> Layout.t;
      compare : (int -> int -> int) option;
      (* use "compare i1 i2" in order to compare entries i1 and i2 *)
      width : int option;
    }
  type t

  val create : ?w:int -> h:int -> ?row_height:int ->
    ?name:string ->
    column list -> Layout.t * (Selection.t, Selection.t) Tvar.t
  (** @return a layout and a Tvar. The Tvar can be used to see which rows were
     selected by the user, and also to modify the selection if needed. *)
end (* of Table *)

(* ---------------------------------------------------------------------------- *)

(** {2 The Bogue mainloop}

Because a GUI continuously waits for user interaction, everything has to run
   inside a loop.  *)

(** Control the workflow of the GUI mainloop 

{5 {{:graph-b_main.html}Dependency graph}}
*)
module Main : sig
  type board
  (** The board is the whole universe of your GUI. It contains everything. *)
  
  exception Exit
  (** Raising the [Exit] exception will tell the GUI loop to terminate. *)

  val exit_on_escape : int * int * (board -> unit)
  (** If the [exit_on_escape] shortcut is given to the {!make} function, then
     the {!Exit} exception will be raised upon pressing the Escape key. *)
  
  val make : ?shortcuts:(int * int * (board -> unit)) list ->
    Widget.connection list -> Layout.t list -> board
  (** Create a [board] from a list of layouts and connections. The list of
     connections can be empty, because connections can be added afterwards. Each
     Layout in the list will open as a new window. The optional argument
     [shortcuts] is a list of shortcut triples of the form [keycode, keymod,
     action].  *)
  
  val run :
    ?before_display:(unit -> unit) ->
    ?after_display:(unit -> unit) -> board -> unit
  (** Launch the main loop. *)
  
  (** {2 Using Bogue together with another graphics loop} 

      See the [embed] example. *)
    
  val make_sdl_windows : ?windows:Tsdl.Sdl.window list -> board -> unit
  (** This is only useful if you have your own graphics loop, and do {e not} use
     {!run}. This function creates an SDL window for each top layout in the
     board. One can use predefined windows with the optional argument
     [windows]. They will be used by the layouts in the order they appear in the
     list. If there are fewer windows than layouts, new windows are created. If
      there are more, the excess is disregarded. *)

  val refresh_custom_windows : board -> unit
  (** Ask the GUI to refresh (ie. repaint) the custom windows (those that were
     not created by Bogue itself). *)
  
  val one_step : ?before_display:(unit -> unit) ->
    bool -> (unit -> unit) * (unit -> unit) -> ?clear:bool -> board -> bool
(** This is only useful if you have your own graphics loop, and do {e not} use
   {!run}. Calling [one_step ~before_display anim (start_fps, fps) ~clear board]
   is what is executed at each step of the Bogue mainloop. If [anim=true] this
   step is {e non blocking}; this is what you want if either Bogue or your loop
   has an animation running. If [anim=false] then the function will wait until
   an event is received.
   @return [true] if the GUI currently handles an animation. In this case
   [fps()] was executed by [one_step]. If not, you should handle the frame rate
   yourself. *)

  val quit : unit -> unit
(** Use this to close SDL windows and cleanup memory, after {!run} has
   returned. *)
    
end (* of Main *)

(* ---------------------------------------------------------------------------- *)

(** Alias for {!Main} *)
module Bogue = Main
  
(* ---------------------------------------------------------------------------- *)

(** {2:example Example}

    Here is a minimal example with a label and a check box.

{[
open Bogue
module W = Widget
module L = Layout

let main () =

  let b = W.check_box () in
  let l = W.label "Hello world" in
  let layout = L.flat_of_w [b;l] in

  let board = Bogue.make [] [layout] in
  Bogue.run board;;

let () = main ();
  Draw.quit ()
]}

This can be compiled to bytecode with

{v
ocamlfind ocamlc -package bogue -linkpkg -o minimal -thread minimal.ml
v}

and to native code with

{v
ocamlfind ocamlopt -package bogue -linkpkg -o minimal -thread minimal.ml
v}

  *)
